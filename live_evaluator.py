import data_processor
import model_lib
from sklearn.preprocessing import RobustScaler
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.pipeline import make_pipeline


if __name__ == "__main__":
    train_set = data_processor.read_dataset("training.json")
    valid_set = data_processor.read_dataset("validation.json")
    combined_set = data_processor.read_dataset("dataset.json")

    if train_set is None:
        print("정제된 훈련 데이터가 없습니다. 새로 생성합니다.")
        train_set = data_processor.process_dataset("TRAIN")
        data_processor.write_dataset("training.json", train_set)

    if valid_set is None:
        print("정제된 검증 데이터가 없습니다. 새로 생성합니다.")
        valid_set = data_processor.process_dataset("VALID")
        data_processor.write_dataset("validation.json", valid_set)

    if combined_set is None:
        print("정제한 합본 데이터셋이 존재하지 않습니다. 새로 생성합니다.")
        combined_set = data_processor.combine_dataset(
            train_set,
            valid_set
        )
        data_processor.write_dataset("dataset.json", combined_set)
    combined_X = combined_set["data"]
    combined_y = combined_set["target"]

    while True:
        print("다음 중 원하는 평가 방법을 입력")
        print("1: holdout validation")
        print("2: k-fold cross validation")
        print("유효하지 않은 값일 경우 프로세스 종료")
        evaluate_type = input()

        if evaluate_type != "1" and evaluate_type != "2":
            print("유효하지 않은 값 입력됨. 프로세스 종료")
            break

        val = input("측정을 원하는 모델을 입력(유효하지 않은 값일 경우 프로세스 종료): ")
        model = model_lib.load_model(model=val, random_state=41)
        if model is None:
            print("유효하지 않은 값 입력됨. 프로세스 종료")
            break
        # pipe = make_pipeline(
        #     StandardScaler(),
        #     model
        # )

        if evaluate_type == "1":
            model.fit(
                train_set["data"],
                train_set["target"],
            )
            model_lib.evaluate(
                valid_set["data"],
                valid_set["target"],
                model
            )
        else:
            model_lib.evaluate_kfold(combined_X, combined_y, model)
